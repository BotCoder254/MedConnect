/**
 * Chat Models for the messaging system
 */

/**
 * Chat Model
 * 
 * Represents a chat conversation between a doctor and a patient
 */
export const ChatModel = {
  id: '', // Auto-generated by Firestore
  participants: [], // Array of user IDs
  participantsInfo: {}, // Map of user IDs to basic user info (name, role, avatar)
  lastMessage: {
    text: '',
    senderId: '',
    createdAt: null,
    isRead: false
  },
  createdAt: null,
  updatedAt: null,
  metadata: {
    appointmentId: null, // Optional reference to an appointment
    isActive: true
  }
};

/**
 * Message Model
 * 
 * Represents a single message in a chat
 */
export const MessageModel = {
  id: '', // Auto-generated by Firestore
  chatId: '', // Reference to the parent chat
  senderId: '', // User ID of the sender
  text: '', // Message text content
  attachments: [], // Array of attachment objects
  createdAt: null, // Timestamp when the message was created
  updatedAt: null, // Timestamp when the message was last updated
  readBy: {}, // Map of user IDs to read timestamps
  status: 'sent', // 'sending', 'sent', 'delivered', 'read', 'error'
  isDeleted: false, // Soft delete flag
  replyTo: null, // Optional reference to another message (for replies)
  metadata: {} // Additional metadata
};

/**
 * Attachment Model
 * 
 * Represents a file attachment in a message
 */
export const AttachmentModel = {
  id: '', // Auto-generated unique ID
  type: '', // 'image', 'document', 'audio', 'video'
  url: '', // Storage URL to the file
  thumbnailUrl: '', // Thumbnail URL (for images/videos)
  name: '', // Original file name
  size: 0, // File size in bytes
  contentType: '', // MIME type
  metadata: {} // Additional metadata
};

/**
 * Typing Indicator Model
 * 
 * Represents a typing indicator in a chat
 */
export const TypingIndicatorModel = {
  chatId: '', // Reference to the chat
  userId: '', // User who is typing
  timestamp: null // When the typing started
};

/**
 * Format timestamp for display
 * 
 * @param {Date|Object} timestamp - Timestamp to format
 * @returns {string} Formatted timestamp
 */
export const formatMessageTimestamp = (timestamp) => {
  if (!timestamp) return '';
  
  // Convert Firebase timestamp to JS Date if needed
  const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
  const now = new Date();
  const diff = now - date;
  
  // Today
  if (diff < 24 * 60 * 60 * 1000 && 
      date.getDate() === now.getDate() &&
      date.getMonth() === now.getMonth() &&
      date.getFullYear() === now.getFullYear()) {
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  // Yesterday
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  if (date.getDate() === yesterday.getDate() &&
      date.getMonth() === yesterday.getMonth() &&
      date.getFullYear() === yesterday.getFullYear()) {
    return `Yesterday, ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
  }
  
  // This week (within 7 days)
  if (diff < 7 * 24 * 60 * 60 * 1000) {
    return `${date.toLocaleDateString([], { weekday: 'short' })}, ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
  }
  
  // Older
  return date.toLocaleDateString([], { month: 'short', day: 'numeric', year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined });
};

/**
 * Group messages by date
 * 
 * @param {Array} messages - Array of messages
 * @returns {Object} Messages grouped by date
 */
export const groupMessagesByDate = (messages) => {
  const grouped = {};
  
  messages.forEach(message => {
    const date = message.createdAt?.toDate ? message.createdAt.toDate() : new Date(message.createdAt);
    const dateStr = date.toLocaleDateString();
    
    if (!grouped[dateStr]) {
      grouped[dateStr] = [];
    }
    
    grouped[dateStr].push(message);
  });
  
  return grouped;
};

/**
 * Format file size for display
 * 
 * @param {number} bytes - Size in bytes
 * @returns {string} Formatted size
 */
export const formatFileSize = (bytes) => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

/**
 * Get file type icon based on MIME type
 * 
 * @param {string} mimeType - MIME type
 * @returns {string} Icon name
 */
export const getFileTypeIcon = (mimeType) => {
  if (!mimeType) return 'file';
  
  if (mimeType.startsWith('image/')) return 'image';
  if (mimeType.startsWith('video/')) return 'video';
  if (mimeType.startsWith('audio/')) return 'music';
  if (mimeType === 'application/pdf') return 'file-text';
  if (mimeType.includes('spreadsheet') || mimeType.includes('excel')) return 'file-spreadsheet';
  if (mimeType.includes('presentation') || mimeType.includes('powerpoint')) return 'file-presentation';
  if (mimeType.includes('document') || mimeType.includes('word')) return 'file-text';
  
  return 'file';
};
